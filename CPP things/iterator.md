#  Iterator


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [Iterator](#iterator)
  - [1迭代器类型](#1迭代器类型)
    - [1.1 **输入迭代器**](#11-输入迭代器)
    - [1.2 **输出迭代器**](#12-输出迭代器)
    - [1.3 **正向迭代器**](#13-正向迭代器)
    - [1.4 **双向迭代器**](#14-双向迭代器)
    - [1.5 **随机访问迭代器**](#15-随机访问迭代器)

<!-- /code_chunk_output -->




&emsp;&emsp;迭代器属于广义指针, 用于把算法从数据类型中分离出来. 因为类方法只适用于特定类型, 所以STL形成了众多通用方法. 但不同类所需要求不同, 故应有不同类型的迭代器, 总结有以下共同点.

<br/>

1. **解引用**
2. **迭代器间相赋值(同类型)**
3. **相比较 == 和 != (确定结尾)**
4. **能够使用迭代器进行遍历**

<br/>

## 1迭代器类型

```
1. 输入迭代器
2. 输出迭代器
3. 正向迭代器
4. 双向迭代器
5. 随机访问迭代器
```

### 1.1 **输入迭代器**

<br/>

&emsp;&emsp;从程序角度来说是输入, 即从容器中读取内容(但不一定能修改). 必须能够对其进行递增操作++(前缀或后缀), 并不能保证第二次遍历时仍然容器内容顺序不变. 所以应当实单同行的, 只能递增, 不能递减.
&emsp;&emsp;递增输入迭代器的任何副本后, 无法安全地比较, 取消引用或递增其他任何副本。

### 1.2 **输出迭代器**

<br/>

&emsp;&emsp;从程序角度来说是输出, 即向容器写入内容(但不一定能读取). STL迭代器是广义的, 也可以将输出(输入)流抽象为容器, 并抽象出迭代器(不能逆向遍历).
&emsp;&emsp;所以输入输出均是单向迭代器

<br/>

***输入输出迭代器比较特殊,用于输入输出流而不是容器,故只能递增而不能递减***

### 1.3 **正向迭代器**

<br/>

&emsp;&emsp;正向迭代器也只使用++运算符遍历容器, 每次向前移动一个元素. 与前两个不同, 可以沿相同顺序遍历容器. 也可以通过保存副本来解引用求值. 

### 1.4 **双向迭代器**

<br/>

&emsp;&emsp;双向迭代器可以双向遍历容器(递增递减)

### 1.5 **随机访问迭代器**

<br/>

&emsp;&emsp;随机访问迭代器可以直接跳转任何一个元素 ( sort()等算法需要). 支持类似指针的运算.

<br/>

&emsp;&emsp;上述迭代器具有一定层次结构, 但不能用继承来描述, 因为各容器实现迭代器类型可能不一样( 可能为指针, 也可能是类对象). 有些文献称之为改进( refinement). 

<br/>

&emsp;&emsp;迭代器使用 <iterator>, <algorithm> --> namespace std

```CPP
  //输入输出


  ostream_iterator<int, char> oi(cout, " ");
	//指向输出流的迭代器
	//int是指传送数据 char是输出流所用字符
	//构造函数用cout表明指向标准输出(屏幕), 并用" "分割每一项

  copy(a.begin(), a.end(), oi);
  //copy()算法利用迭代器确定区间[ a.begin(), a.end())
  //a.end()是超尾迭代器, 故不实际使用其元素

  isream_iterator<int, char> ii(cin, " ");
  //为输入迭代器

  copy( ii, istream< int, char>(), dice.begin());
  //使用默认构造函数即输入失败
  //所以读取内容至错误



```
<br/>


```C++
  //其它有用迭代器

  //reverse_iterator对其执行递增操作实际会递减(正向迭代器)
  //故可以对容器逆向操作

  copy( dice.rbegin(), dice.rend(), oi);
  //反向打印容器内容
  //cpp reference上指明rbegin()指向的是最后一个元素,而rend()指向的是第一个元素前面的位置.这样符合STL通用区间
  //而上面的oi则不允许有反向迭代器--不能反向发送字符流

  //三种插入迭代器
  //insert_iterator front_insert_iterator back_insert_iterator
  //原有方法 ( dice.begin()) 会擦除原有容器内容而不是增大容器大小,所以会引发内存问题

  //insert_iterator插入到构造函数指定位置
  //front_insert_iterator插入到容器开头
  //back_insert_iterator插入到容器末尾

  //insert_iterator< vector< int>> iter( dice, dice.begin())
  //声明类型是为了合适调整容器大小( 通过迭代器)
  //back_insert_itertor同, 但不用声明插入位置, 必须用于可在尾部快速插入的容器
  //front_insert_iterator必须用于在开头固定时间插入的容器


```